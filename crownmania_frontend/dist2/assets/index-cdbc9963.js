import{k as x}from"./sha3-dabe8d6f.js";import{m as g,o as U,p as b,c as H,b as _,u as v}from"./secp256k1-e5c7fdd6.js";const $=g.bool,k=g.bytes;function S(e){if(!(e instanceof Uint8Array))throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof e}`);return new TextDecoder().decode(e)}function j(e){const t=e.startsWith("0x")?e.substring(2):e;return U(t)}function q(e,t){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}function T(e){return t=>(g.bytes(t),e(t))}const N=(()=>{const e=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0,t=typeof module<"u"&&typeof module.require=="function"&&module.require.bind(module);return{node:t&&!e?t("crypto"):void 0,web:e}})(),V=Object.freeze(Object.defineProperty({__proto__:null,assertBool:$,assertBytes:k,bytesToHex:b,bytesToUtf8:S,concatBytes:H,createView:_,crypto:N,equalsBytes:q,hexToBytes:j,toHex:b,utf8ToBytes:v,wrapHash:T},Symbol.toStringTag,{value:"Module"})),W=(()=>{const e=T(x);return e.create=x.create,e})();var f={};Object.defineProperty(f,"__esModule",{value:!0});var z=f.RLP=f.utils=f.decode=f.encode=void 0;function w(e){if(Array.isArray(e)){const r=[];let n=0;for(let o=0;o<e.length;o++){const i=w(e[o]);r.push(i),n+=i.length}return h(p(n,192),...r)}const t=R(e);return t.length===1&&t[0]<128?t:h(p(t.length,128),t)}f.encode=w;function c(e,t,r){if(r>e.length)throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");return e.slice(t,r)}function m(e){if(e[0]===0)throw new Error("invalid RLP: extra zeros");return E(L(e))}function p(e,t){if(e<56)return Uint8Array.from([e+t]);const r=y(e),n=r.length/2,o=y(t+55+n);return Uint8Array.from(a(o+r))}function B(e,t=!1){if(typeof e>"u"||e===null||e.length===0)return Uint8Array.from([]);const r=R(e),n=u(r);if(t)return n;if(n.remainder.length!==0)throw new Error("invalid RLP: remainder must be zero");return n.data}f.decode=B;function u(e){let t,r,n,o,i;const l=[],s=e[0];if(s<=127)return{data:e.slice(0,1),remainder:e.slice(1)};if(s<=183){if(t=s-127,s===128?n=Uint8Array.from([]):n=c(e,1,t),t===2&&n[0]<128)throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");return{data:n,remainder:e.slice(t)}}else if(s<=191){if(r=s-182,e.length-1<r)throw new Error("invalid RLP: not enough bytes for string length");if(t=m(c(e,1,r)),t<=55)throw new Error("invalid RLP: expected string length to be greater than 55");return n=c(e,r,t+r),{data:n,remainder:e.slice(t+r)}}else if(s<=247){for(t=s-191,o=c(e,1,t);o.length;)i=u(o),l.push(i.data),o=i.remainder;return{data:l,remainder:e.slice(t)}}else{if(r=s-246,t=m(c(e,1,r)),t<56)throw new Error("invalid RLP: encoded list too short");const d=r+t;if(d>e.length)throw new Error("invalid RLP: total length is larger than the data");for(o=c(e,r,d);o.length;)i=u(o),l.push(i.data),o=i.remainder;return{data:l,remainder:e.slice(d)}}}const I=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function L(e){let t="";for(let r=0;r<e.length;r++)t+=I[e[r]];return t}function E(e){const t=Number.parseInt(e,16);if(Number.isNaN(t))throw new Error("Invalid byte sequence");return t}function a(e){if(typeof e!="string")throw new TypeError("hexToBytes: expected string, got "+typeof e);if(e.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const t=new Uint8Array(e.length/2);for(let r=0;r<t.length;r++){const n=r*2;t[r]=E(e.slice(n,n+2))}return t}function h(...e){if(e.length===1)return e[0];const t=e.reduce((n,o)=>n+o.length,0),r=new Uint8Array(t);for(let n=0,o=0;n<e.length;n++){const i=e[n];r.set(i,o),o+=i.length}return r}function A(e){return new TextEncoder().encode(e)}function y(e){if(e<0)throw new Error("Invalid integer as argument, must be unsigned!");const t=e.toString(16);return t.length%2?`0${t}`:t}function O(e){return e.length%2?`0${e}`:e}function P(e){return e.length>=2&&e[0]==="0"&&e[1]==="x"}function M(e){return typeof e!="string"?e:P(e)?e.slice(2):e}function R(e){if(e instanceof Uint8Array)return e;if(typeof e=="string")return P(e)?a(O(M(e))):A(e);if(typeof e=="number"||typeof e=="bigint")return e?a(y(e)):Uint8Array.from([]);if(e==null)return Uint8Array.from([]);throw new Error("toBytes: received unsupported type "+typeof e)}f.utils={bytesToHex:L,concatBytes:h,hexToBytes:a,utf8ToBytes:A};z=f.RLP={encode:w,decode:B};export{z as R,k as a,S as b,f as d,q as e,W as k,V as u,T as w};
