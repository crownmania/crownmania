function At(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function be(t){if(typeof t!="boolean")throw new Error(`boolean expected, not ${t}`)}function we(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function ht(t,...e){if(!we(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}function Dt(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");At(t.outputLen),At(t.blockLen)}function yt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Kt(t,e){ht(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const Ve={number:At,bool:be,bytes:ht,hash:Dt,exists:yt,output:Kt},Ze=Ve,Fn=Object.freeze(Object.defineProperty({__proto__:null,bool:be,bytes:ht,default:Ze,exists:yt,hash:Dt,isBytes:we,number:At,output:Kt},Symbol.toStringTag,{value:"Module"})),Ct=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function je(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}const Pe=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength),ze=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),St=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),G=(t,e)=>t<<32-e|t>>>e,Me=(t,e)=>t<<e|t>>>32-e>>>0,ye=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,Yt=t=>t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255,De=ye?t=>t:t=>Yt(t);function Ke(t){for(let e=0;e<t.length;e++)t[e]=Yt(t[e])}const Ye=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Ge(t){ht(t);let e="";for(let n=0;n<t.length;n++)e+=Ye[t[n]];return e}const Q={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function ie(t){if(t>=Q._0&&t<=Q._9)return t-Q._0;if(t>=Q._A&&t<=Q._F)return t-(Q._A-10);if(t>=Q._a&&t<=Q._f)return t-(Q._a-10)}function We(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){const f=ie(t.charCodeAt(s)),i=ie(t.charCodeAt(s+1));if(f===void 0||i===void 0){const c=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}r[o]=f*16+i}return r}const me=async()=>{};async function Xe(t,e,n){let r=Date.now();for(let o=0;o<t;o++){n(o);const s=Date.now()-r;s>=0&&s<e||(await me(),r+=s)}}function pe(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function xt(t){return typeof t=="string"&&(t=pe(t)),ht(t),t}function xe(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];ht(o),e+=o.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const s=t[r];n.set(s,o),o+=s.length}return n}class Gt{clone(){return this._cloneInto()}}const Qe={}.toString;function Je(t,e){if(e!==void 0&&Qe.call(e)!=="[object Object]")throw new Error("Options should be object or undefined");return Object.assign(t,e)}function Ee(t){const e=r=>t().update(xt(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function Fe(t){const e=(r,o)=>t(o).update(xt(r)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=r=>t(r),e}function tn(t){const e=(r,o)=>t(o).update(xt(r)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=r=>t(r),e}function Wt(t=32){if(Ct&&typeof Ct.getRandomValues=="function")return Ct.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}const tr=Object.freeze(Object.defineProperty({__proto__:null,Hash:Gt,asyncLoop:Xe,byteSwap:Yt,byteSwap32:Ke,byteSwapIfBE:De,bytesToHex:Ge,checkOpts:Je,concatBytes:xe,createView:St,hexToBytes:We,isBytes:je,isLE:ye,nextTick:me,randomBytes:Wt,rotl:Me,rotr:G,toBytes:xt,u32:ze,u8:Pe,utf8ToBytes:pe,wrapConstructor:Ee,wrapConstructorWithOpts:Fe,wrapXOFConstructorWithOpts:tn},Symbol.toStringTag,{value:"Module"}));function en(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),s=BigInt(4294967295),f=Number(n>>o&s),i=Number(n&s),c=r?4:0,a=r?0:4;t.setUint32(e+c,f,r),t.setUint32(e+a,i,r)}const nn=(t,e,n)=>t&e^~t&n,rn=(t,e,n)=>t&e^t&n^e&n;class on extends Gt{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=St(this.buffer)}update(e){yt(this);const{view:n,buffer:r,blockLen:o}=this;e=xt(e);const s=e.length;for(let f=0;f<s;){const i=Math.min(o-this.pos,s-f);if(i===o){const c=St(e);for(;o<=s-f;f+=o)this.process(c,f);continue}r.set(e.subarray(f,f+i),this.pos),this.pos+=i,f+=i,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){yt(this),Kt(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:f}=this;n[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>o-f&&(this.process(r,0),f=0);for(let u=f;u<o;u++)n[u]=0;en(r,o-8,BigInt(this.length*8),s),this.process(r,0);const i=St(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4,h=this.get();if(a>h.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)i.setUint32(4*u,h[u],s)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:f,pos:i}=this;return e.length=o,e.pos=i,e.finished=s,e.destroyed=f,o%n&&e.buffer.set(r),e}}const sn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),rt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ot=new Uint32Array(64);class cn extends on{constructor(){super(64,32,8,!1),this.A=rt[0]|0,this.B=rt[1]|0,this.C=rt[2]|0,this.D=rt[3]|0,this.E=rt[4]|0,this.F=rt[5]|0,this.G=rt[6]|0,this.H=rt[7]|0}get(){const{A:e,B:n,C:r,D:o,E:s,F:f,G:i,H:c}=this;return[e,n,r,o,s,f,i,c]}set(e,n,r,o,s,f,i,c){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=f|0,this.G=i|0,this.H=c|0}process(e,n){for(let u=0;u<16;u++,n+=4)ot[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const v=ot[u-15],E=ot[u-2],y=G(v,7)^G(v,18)^v>>>3,l=G(E,17)^G(E,19)^E>>>10;ot[u]=l+ot[u-7]+y+ot[u-16]|0}let{A:r,B:o,C:s,D:f,E:i,F:c,G:a,H:h}=this;for(let u=0;u<64;u++){const v=G(i,6)^G(i,11)^G(i,25),E=h+v+nn(i,c,a)+sn[u]+ot[u]|0,l=(G(r,2)^G(r,13)^G(r,22))+rn(r,o,s)|0;h=a,a=c,c=i,i=f+E|0,f=s,s=o,o=r,r=E+l|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,f=f+this.D|0,i=i+this.E|0,c=c+this.F|0,a=a+this.G|0,h=h+this.H|0,this.set(r,o,s,f,i,c,a,h)}roundClean(){ot.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const It=Ee(()=>new cn);class Be extends Gt{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,Dt(e);const r=xt(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?e.create().update(r).digest():r);for(let f=0;f<s.length;f++)s[f]^=54;this.iHash.update(s),this.oHash=e.create();for(let f=0;f<s.length;f++)s[f]^=106;this.oHash.update(s),s.fill(0)}update(e){return yt(this),this.iHash.update(e),this}digestInto(e){yt(this),ht(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:f,outputLen:i}=this;return e=e,e.finished=o,e.destroyed=s,e.blockLen=f,e.outputLen=i,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ve=(t,e,n)=>new Be(t,e).update(n).digest();ve.create=(t,e)=>new Be(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _e=BigInt(0),Ut=BigInt(1),fn=BigInt(2);function dt(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function X(t){if(!dt(t))throw new Error("Uint8Array expected")}const an=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function mt(t){X(t);let e="";for(let n=0;n<t.length;n++)e+=an[t[n]];return e}function Se(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function Xt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}const J={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function ce(t){if(t>=J._0&&t<=J._9)return t-J._0;if(t>=J._A&&t<=J._F)return t-(J._A-10);if(t>=J._a&&t<=J._f)return t-(J._a-10)}function pt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let o=0,s=0;o<n;o++,s+=2){const f=ce(t.charCodeAt(s)),i=ce(t.charCodeAt(s+1));if(f===void 0||i===void 0){const c=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+s)}r[o]=f*16+i}return r}function V(t){return Xt(mt(t))}function Qt(t){return X(t),Xt(mt(Uint8Array.from(t).reverse()))}function ct(t,e){return pt(t.toString(16).padStart(e*2,"0"))}function Jt(t,e){return ct(t,e).reverse()}function un(t){return pt(Se(t))}function C(t,e,n){let r;if(typeof e=="string")try{r=pt(e)}catch(s){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`)}else if(dt(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function M(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];X(o),e+=o.length}const n=new Uint8Array(e);for(let r=0,o=0;r<t.length;r++){const s=t[r];n.set(s,o),o+=s.length}return n}function ln(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}function Nt(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function dn(t){let e;for(e=0;t>_e;t>>=Ut,e+=1);return e}function hn(t,e){return t>>BigInt(e)&Ut}function gn(t,e,n){return t|(n?Ut:_e)<<BigInt(e)}const Ft=t=>(fn<<BigInt(t-1))-Ut,kt=t=>new Uint8Array(t),fe=t=>Uint8Array.from(t);function Ae(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=kt(t),o=kt(t),s=0;const f=()=>{r.fill(1),o.fill(0),s=0},i=(...u)=>n(o,r,...u),c=(u=kt())=>{o=i(fe([0]),u),r=i(),u.length!==0&&(o=i(fe([1]),u),r=i())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const v=[];for(;u<e;){r=i();const E=r.slice();v.push(E),u+=r.length}return M(...v)};return(u,v)=>{f(),c(u);let E;for(;!(E=v(a()));)c();return f(),E}}const bn={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||dt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function Et(t,e,n={}){const r=(o,s,f)=>{const i=bn[s];if(typeof i!="function")throw new Error(`Invalid validator "${s}", expected function`);const c=t[o];if(!(f&&c===void 0)&&!i(c,t))throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${s}`)};for(const[o,s]of Object.entries(e))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return t}const wn=Object.freeze(Object.defineProperty({__proto__:null,abytes:X,bitGet:hn,bitLen:dn,bitMask:Ft,bitSet:gn,bytesToHex:mt,bytesToNumberBE:V,bytesToNumberLE:Qt,concatBytes:M,createHmacDrbg:Ae,ensureBytes:C,equalBytes:ln,hexToBytes:pt,hexToNumber:Xt,isBytes:dt,numberToBytesBE:ct,numberToBytesLE:Jt,numberToHexUnpadded:Se,numberToVarBytesBE:un,utf8ToBytes:Nt,validateObject:Et},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const R=BigInt(0),N=BigInt(1),ut=BigInt(2),yn=BigInt(3),jt=BigInt(4),ae=BigInt(5),ue=BigInt(8);BigInt(9);BigInt(16);function H(t,e){const n=t%e;return n>=R?n:e+n}function mn(t,e,n){if(n<=R||e<R)throw new Error("Expected power/modulo > 0");if(n===N)return R;let r=N;for(;e>R;)e&N&&(r=r*t%n),t=t*t%n,e>>=N;return r}function D(t,e,n){let r=t;for(;e-- >R;)r*=r,r%=n;return r}function Pt(t,e){if(t===R||e<=R)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=H(t,e),r=e,o=R,s=N;for(;n!==R;){const i=r/n,c=r%n,a=o-s*i;r=n,n=c,o=s,s=a}if(r!==N)throw new Error("invert: does not exist");return H(o,e)}function pn(t){const e=(t-N)/ut;let n,r,o;for(n=t-N,r=0;n%ut===R;n/=ut,r++);for(o=ut;o<t&&mn(o,e,t)!==t-N;o++);if(r===1){const f=(t+N)/jt;return function(c,a){const h=c.pow(a,f);if(!c.eql(c.sqr(h),a))throw new Error("Cannot find square root");return h}}const s=(n+N)/ut;return function(i,c){if(i.pow(c,e)===i.neg(i.ONE))throw new Error("Cannot find square root");let a=r,h=i.pow(i.mul(i.ONE,o),n),u=i.pow(c,s),v=i.pow(c,n);for(;!i.eql(v,i.ONE);){if(i.eql(v,i.ZERO))return i.ZERO;let E=1;for(let l=i.sqr(v);E<a&&!i.eql(l,i.ONE);E++)l=i.sqr(l);const y=i.pow(h,N<<BigInt(a-E-1));h=i.sqr(y),u=i.mul(u,y),v=i.mul(v,h),a=E}return u}}function xn(t){if(t%jt===yn){const e=(t+N)/jt;return function(r,o){const s=r.pow(o,e);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%ue===ae){const e=(t-ae)/ue;return function(r,o){const s=r.mul(o,ut),f=r.pow(s,e),i=r.mul(o,f),c=r.mul(r.mul(i,ut),f),a=r.mul(i,r.sub(c,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return pn(t)}const En=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ie(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=En.reduce((r,o)=>(r[o]="function",r),e);return Et(t,n)}function Bn(t,e,n){if(n<R)throw new Error("Expected power > 0");if(n===R)return t.ONE;if(n===N)return e;let r=t.ONE,o=e;for(;n>R;)n&N&&(r=t.mul(r,o)),o=t.sqr(o),n>>=N;return r}function vn(t,e){const n=new Array(e.length),r=e.reduce((s,f,i)=>t.is0(f)?s:(n[i]=s,t.mul(s,f)),t.ONE),o=t.inv(r);return e.reduceRight((s,f,i)=>t.is0(f)?s:(n[i]=t.mul(s,n[i]),t.mul(s,f)),o),n}function Oe(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function _n(t,e,n=!1,r={}){if(t<=R)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:s}=Oe(t,e);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=xn(t),i=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:Ft(o),ZERO:R,ONE:N,create:c=>H(c,t),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return R<=c&&c<t},is0:c=>c===R,isOdd:c=>(c&N)===N,neg:c=>H(-c,t),eql:(c,a)=>c===a,sqr:c=>H(c*c,t),add:(c,a)=>H(c+a,t),sub:(c,a)=>H(c-a,t),mul:(c,a)=>H(c*a,t),pow:(c,a)=>Bn(i,c,a),div:(c,a)=>H(c*Pt(a,t),t),sqrN:c=>c*c,addN:(c,a)=>c+a,subN:(c,a)=>c-a,mulN:(c,a)=>c*a,inv:c=>Pt(c,t),sqrt:r.sqrt||(c=>f(i,c)),invertBatch:c=>vn(i,c),cmov:(c,a,h)=>h?a:c,toBytes:c=>n?Jt(c,s):ct(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return n?Qt(c):V(c)}});return Object.freeze(i)}function qe(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Te(t){const e=qe(t);return e+Math.ceil(e/2)}function Sn(t,e,n=!1){const r=t.length,o=qe(e),s=Te(e);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const f=n?V(t):Qt(t),i=H(f,e-N)+N;return n?Jt(i,o):ct(i,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const An=BigInt(0),Vt=BigInt(1);function In(t,e){const n=(o,s)=>{const f=s.negate();return o?f:s},r=o=>{const s=Math.ceil(e/o)+1,f=2**(o-1);return{windows:s,windowSize:f}};return{constTimeNegate:n,unsafeLadder(o,s){let f=t.ZERO,i=o;for(;s>An;)s&Vt&&(f=f.add(i)),i=i.double(),s>>=Vt;return f},precomputeWindow(o,s){const{windows:f,windowSize:i}=r(s),c=[];let a=o,h=a;for(let u=0;u<f;u++){h=a,c.push(h);for(let v=1;v<i;v++)h=h.add(a),c.push(h);a=h.double()}return c},wNAF(o,s,f){const{windows:i,windowSize:c}=r(o);let a=t.ZERO,h=t.BASE;const u=BigInt(2**o-1),v=2**o,E=BigInt(o);for(let y=0;y<i;y++){const l=y*c;let g=Number(f&u);f>>=E,g>c&&(g-=v,f+=Vt);const d=l,w=l+Math.abs(g)-1,p=y%2!==0,_=g<0;g===0?h=h.add(n(p,s[d])):a=a.add(n(_,s[w]))}return{p:a,f:h}},wNAFCached(o,s,f,i){const c=o._WINDOW_SIZE||1;let a=s.get(o);return a||(a=this.precomputeWindow(o,c),c!==1&&s.set(o,i(a))),this.wNAF(c,a,f)}}}function Le(t){return Ie(t.Fp),Et(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Oe(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function On(t){const e=Le(t);Et(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:qn,hexToBytes:Tn}=wn,lt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=lt;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:qn(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=lt,n=typeof t=="string"?Tn(t):t;X(n);let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:s}=lt._parseInt(n.subarray(2)),{d:f,l:i}=lt._parseInt(s);if(i.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s:f}},hexFromSig(t){const e=a=>Number.parseInt(a[0],16)&8?"00"+a:a,n=a=>{const h=a.toString(16);return h.length&1?`0${h}`:h},r=e(n(t.s)),o=e(n(t.r)),s=r.length/2,f=o.length/2,i=n(s),c=n(f);return`30${n(f+s+4)}02${c}${o}02${i}${r}`}},W=BigInt(0),U=BigInt(1),st=BigInt(2),Ot=BigInt(3),le=BigInt(4);function Ln(t){const e=On(t),{Fp:n}=e,r=e.toBytes||((y,l,g)=>{const d=l.toAffine();return M(Uint8Array.from([4]),n.toBytes(d.x),n.toBytes(d.y))}),o=e.fromBytes||(y=>{const l=y.subarray(1),g=n.fromBytes(l.subarray(0,n.BYTES)),d=n.fromBytes(l.subarray(n.BYTES,2*n.BYTES));return{x:g,y:d}});function s(y){const{a:l,b:g}=e,d=n.sqr(y),w=n.mul(d,y);return n.add(n.add(w,n.mul(y,l)),g)}if(!n.eql(n.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function f(y){return typeof y=="bigint"&&W<y&&y<e.n}function i(y){if(!f(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(y){const{allowedPrivateKeyLengths:l,nByteLength:g,wrapPrivateKey:d,n:w}=e;if(l&&typeof y!="bigint"){if(dt(y)&&(y=mt(y)),typeof y!="string"||!l.includes(y.length))throw new Error("Invalid key");y=y.padStart(g*2,"0")}let p;try{p=typeof y=="bigint"?y:V(C("private key",y,g))}catch{throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof y}`)}return d&&(p=H(p,w)),i(p),p}const a=new Map;function h(y){if(!(y instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,g,d){if(this.px=l,this.py=g,this.pz=d,l==null||!n.isValid(l))throw new Error("x required");if(g==null||!n.isValid(g))throw new Error("y required");if(d==null||!n.isValid(d))throw new Error("z required")}static fromAffine(l){const{x:g,y:d}=l||{};if(!l||!n.isValid(g)||!n.isValid(d))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");const w=p=>n.eql(p,n.ZERO);return w(g)&&w(d)?u.ZERO:new u(g,d,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const g=n.invertBatch(l.map(d=>d.pz));return l.map((d,w)=>d.toAffine(g[w])).map(u.fromAffine)}static fromHex(l){const g=u.fromAffine(o(C("pointHex",l)));return g.assertValidity(),g}static fromPrivateKey(l){return u.BASE.multiply(c(l))}_setWindowSize(l){this._WINDOW_SIZE=l,a.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:l,y:g}=this.toAffine();if(!n.isValid(l)||!n.isValid(g))throw new Error("bad point: x or y not FE");const d=n.sqr(g),w=s(l);if(!n.eql(d,w))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(n.isOdd)return!n.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){h(l);const{px:g,py:d,pz:w}=this,{px:p,py:_,pz:A}=l,x=n.eql(n.mul(g,A),n.mul(p,w)),B=n.eql(n.mul(d,A),n.mul(_,w));return x&&B}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:l,b:g}=e,d=n.mul(g,Ot),{px:w,py:p,pz:_}=this;let A=n.ZERO,x=n.ZERO,B=n.ZERO,S=n.mul(w,w),k=n.mul(p,p),L=n.mul(_,_),O=n.mul(w,p);return O=n.add(O,O),B=n.mul(w,_),B=n.add(B,B),A=n.mul(l,B),x=n.mul(d,L),x=n.add(A,x),A=n.sub(k,x),x=n.add(k,x),x=n.mul(A,x),A=n.mul(O,A),B=n.mul(d,B),L=n.mul(l,L),O=n.sub(S,L),O=n.mul(l,O),O=n.add(O,B),B=n.add(S,S),S=n.add(B,S),S=n.add(S,L),S=n.mul(S,O),x=n.add(x,S),L=n.mul(p,_),L=n.add(L,L),S=n.mul(L,O),A=n.sub(A,S),B=n.mul(L,k),B=n.add(B,B),B=n.add(B,B),new u(A,x,B)}add(l){h(l);const{px:g,py:d,pz:w}=this,{px:p,py:_,pz:A}=l;let x=n.ZERO,B=n.ZERO,S=n.ZERO;const k=e.a,L=n.mul(e.b,Ot);let O=n.mul(g,p),P=n.mul(d,_),z=n.mul(w,A),F=n.add(g,d),b=n.add(p,_);F=n.mul(F,b),b=n.add(O,P),F=n.sub(F,b),b=n.add(g,w);let m=n.add(p,A);return b=n.mul(b,m),m=n.add(O,z),b=n.sub(b,m),m=n.add(d,w),x=n.add(_,A),m=n.mul(m,x),x=n.add(P,z),m=n.sub(m,x),S=n.mul(k,b),x=n.mul(L,z),S=n.add(x,S),x=n.sub(P,S),S=n.add(P,S),B=n.mul(x,S),P=n.add(O,O),P=n.add(P,O),z=n.mul(k,z),b=n.mul(L,b),P=n.add(P,z),z=n.sub(O,z),z=n.mul(k,z),b=n.add(b,z),O=n.mul(P,b),B=n.add(B,O),O=n.mul(m,b),x=n.mul(F,x),x=n.sub(x,O),O=n.mul(F,P),S=n.mul(m,S),S=n.add(S,O),new u(x,B,S)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return E.wNAFCached(this,a,l,g=>{const d=n.invertBatch(g.map(w=>w.pz));return g.map((w,p)=>w.toAffine(d[p])).map(u.fromAffine)})}multiplyUnsafe(l){const g=u.ZERO;if(l===W)return g;if(i(l),l===U)return this;const{endo:d}=e;if(!d)return E.unsafeLadder(this,l);let{k1neg:w,k1:p,k2neg:_,k2:A}=d.splitScalar(l),x=g,B=g,S=this;for(;p>W||A>W;)p&U&&(x=x.add(S)),A&U&&(B=B.add(S)),S=S.double(),p>>=U,A>>=U;return w&&(x=x.negate()),_&&(B=B.negate()),B=new u(n.mul(B.px,d.beta),B.py,B.pz),x.add(B)}multiply(l){i(l);let g=l,d,w;const{endo:p}=e;if(p){const{k1neg:_,k1:A,k2neg:x,k2:B}=p.splitScalar(g);let{p:S,f:k}=this.wNAF(A),{p:L,f:O}=this.wNAF(B);S=E.constTimeNegate(_,S),L=E.constTimeNegate(x,L),L=new u(n.mul(L.px,p.beta),L.py,L.pz),d=S.add(L),w=k.add(O)}else{const{p:_,f:A}=this.wNAF(g);d=_,w=A}return u.normalizeZ([d,w])[0]}multiplyAndAddUnsafe(l,g,d){const w=u.BASE,p=(A,x)=>x===W||x===U||!A.equals(w)?A.multiplyUnsafe(x):A.multiply(x),_=p(this,g).add(p(l,d));return _.is0()?void 0:_}toAffine(l){const{px:g,py:d,pz:w}=this,p=this.is0();l==null&&(l=p?n.ONE:n.inv(w));const _=n.mul(g,l),A=n.mul(d,l),x=n.mul(w,l);if(p)return{x:n.ZERO,y:n.ZERO};if(!n.eql(x,n.ONE))throw new Error("invZ was invalid");return{x:_,y:A}}isTorsionFree(){const{h:l,isTorsionFree:g}=e;if(l===U)return!0;if(g)return g(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:g}=e;return l===U?this:g?g(u,this):this.multiplyUnsafe(e.h)}toRawBytes(l=!0){return this.assertValidity(),r(u,this,l)}toHex(l=!0){return mt(this.toRawBytes(l))}}u.BASE=new u(e.Gx,e.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const v=e.nBitLength,E=In(u,e.endo?Math.ceil(v/2):v);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:f}}function Un(t){const e=Le(t);return Et(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Nn(t){const e=Un(t),{Fp:n,n:r}=e,o=n.BYTES+1,s=2*n.BYTES+1;function f(b){return W<b&&b<n.ORDER}function i(b){return H(b,r)}function c(b){return Pt(b,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:h,weierstrassEquation:u,isWithinCurveOrder:v}=Ln({...e,toBytes(b,m,I){const T=m.toAffine(),q=n.toBytes(T.x),$=M;return I?$(Uint8Array.from([m.hasEvenY()?2:3]),q):$(Uint8Array.from([4]),q,n.toBytes(T.y))},fromBytes(b){const m=b.length,I=b[0],T=b.subarray(1);if(m===o&&(I===2||I===3)){const q=V(T);if(!f(q))throw new Error("Point is not on curve");const $=u(q);let Z;try{Z=n.sqrt($)}catch(K){const et=K instanceof Error?": "+K.message:"";throw new Error("Point is not on curve"+et)}const j=(Z&U)===U;return(I&1)===1!==j&&(Z=n.neg(Z)),{x:q,y:Z}}else if(m===s&&I===4){const q=n.fromBytes(T.subarray(0,n.BYTES)),$=n.fromBytes(T.subarray(n.BYTES,2*n.BYTES));return{x:q,y:$}}else throw new Error(`Point of length ${m} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),E=b=>mt(ct(b,e.nByteLength));function y(b){const m=r>>U;return b>m}function l(b){return y(b)?i(-b):b}const g=(b,m,I)=>V(b.slice(m,I));class d{constructor(m,I,T){this.r=m,this.s=I,this.recovery=T,this.assertValidity()}static fromCompact(m){const I=e.nByteLength;return m=C("compactSignature",m,I*2),new d(g(m,0,I),g(m,I,2*I))}static fromDER(m){const{r:I,s:T}=lt.toSig(C("DER",m));return new d(I,T)}assertValidity(){if(!v(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!v(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(m){return new d(this.r,this.s,m)}recoverPublicKey(m){const{r:I,s:T,recovery:q}=this,$=B(C("msgHash",m));if(q==null||![0,1,2,3].includes(q))throw new Error("recovery id invalid");const Z=q===2||q===3?I+e.n:I;if(Z>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=q&1?"03":"02",tt=a.fromHex(j+E(Z)),K=c(Z),et=i(-$*K),Bt=i(T*K),nt=a.BASE.multiplyAndAddUnsafe(tt,et,Bt);if(!nt)throw new Error("point at infinify");return nt.assertValidity(),nt}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return pt(this.toDERHex())}toDERHex(){return lt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return pt(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const w={isValidPrivateKey(b){try{return h(b),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const b=Te(e.n);return Sn(e.randomBytes(b),e.n)},precompute(b=8,m=a.BASE){return m._setWindowSize(b),m.multiply(BigInt(3)),m}};function p(b,m=!0){return a.fromPrivateKey(b).toRawBytes(m)}function _(b){const m=dt(b),I=typeof b=="string",T=(m||I)&&b.length;return m?T===o||T===s:I?T===2*o||T===2*s:b instanceof a}function A(b,m,I=!0){if(_(b))throw new Error("first arg must be private key");if(!_(m))throw new Error("second arg must be public key");return a.fromHex(m).multiply(h(b)).toRawBytes(I)}const x=e.bits2int||function(b){const m=V(b),I=b.length*8-e.nBitLength;return I>0?m>>BigInt(I):m},B=e.bits2int_modN||function(b){return i(x(b))},S=Ft(e.nBitLength);function k(b){if(typeof b!="bigint")throw new Error("bigint expected");if(!(W<=b&&b<S))throw new Error(`bigint expected < 2^${e.nBitLength}`);return ct(b,e.nByteLength)}function L(b,m,I=O){if(["recovered","canonical"].some(at=>at in I))throw new Error("sign() legacy options not supported");const{hash:T,randomBytes:q}=e;let{lowS:$,prehash:Z,extraEntropy:j}=I;$==null&&($=!0),b=C("msgHash",b),Z&&(b=C("prehashed msgHash",T(b)));const tt=B(b),K=h(m),et=[k(K),k(tt)];if(j!=null&&j!==!1){const at=j===!0?q(n.BYTES):j;et.push(C("extraEntropy",at))}const Bt=M(...et),nt=tt;function Rt(at){const gt=x(at);if(!v(gt))return;const re=c(gt),bt=a.BASE.multiply(gt).toAffine(),Y=i(bt.x);if(Y===W)return;const wt=i(re*i(nt+Y*K));if(wt===W)return;let oe=(bt.x===Y?0:2)|Number(bt.y&U),se=wt;return $&&y(wt)&&(se=l(wt),oe^=1),new d(Y,se,oe)}return{seed:Bt,k2sig:Rt}}const O={lowS:e.lowS,prehash:!1},P={lowS:e.lowS,prehash:!1};function z(b,m,I=O){const{seed:T,k2sig:q}=L(b,m,I),$=e;return Ae($.hash.outputLen,$.nByteLength,$.hmac)(T,q)}a.BASE._setWindowSize(8);function F(b,m,I,T=P){var bt;const q=b;if(m=C("msgHash",m),I=C("publicKey",I),"strict"in T)throw new Error("options.strict was renamed to lowS");const{lowS:$,prehash:Z}=T;let j,tt;try{if(typeof q=="string"||dt(q))try{j=d.fromDER(q)}catch(Y){if(!(Y instanceof lt.Err))throw Y;j=d.fromCompact(q)}else if(typeof q=="object"&&typeof q.r=="bigint"&&typeof q.s=="bigint"){const{r:Y,s:wt}=q;j=new d(Y,wt)}else throw new Error("PARSE");tt=a.fromHex(I)}catch(Y){if(Y.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if($&&j.hasHighS())return!1;Z&&(m=e.hash(m));const{r:K,s:et}=j,Bt=B(m),nt=c(et),Rt=i(Bt*nt),at=i(K*nt),gt=(bt=a.BASE.multiplyAndAddUnsafe(tt,Rt,at))==null?void 0:bt.toAffine();return gt?i(gt.x)===K:!1}return{CURVE:e,getPublicKey:p,getSharedSecret:A,sign:z,verify:F,ProjectivePoint:a,Signature:d,utils:w}}function $n(t,e){const n=t.ORDER;let r=W;for(let y=n-U;y%st===W;y/=st)r+=U;const o=r,s=st<<o-U-U,f=s*st,i=(n-U)/f,c=(i-U)/st,a=f-U,h=s,u=t.pow(e,i),v=t.pow(e,(i+U)/st);let E=(y,l)=>{let g=u,d=t.pow(l,a),w=t.sqr(d);w=t.mul(w,l);let p=t.mul(y,w);p=t.pow(p,c),p=t.mul(p,d),d=t.mul(p,l),w=t.mul(p,y);let _=t.mul(w,d);p=t.pow(_,h);let A=t.eql(p,t.ONE);d=t.mul(w,v),p=t.mul(_,g),w=t.cmov(d,w,A),_=t.cmov(p,_,A);for(let x=o;x>U;x--){let B=x-st;B=st<<B-U;let S=t.pow(_,B);const k=t.eql(S,t.ONE);d=t.mul(w,g),g=t.mul(g,g),S=t.mul(_,g),w=t.cmov(d,w,k),_=t.cmov(S,_,k)}return{isValid:A,value:w}};if(t.ORDER%le===Ot){const y=(t.ORDER-Ot)/le,l=t.sqrt(t.neg(e));E=(g,d)=>{let w=t.sqr(d);const p=t.mul(g,d);w=t.mul(w,p);let _=t.pow(w,y);_=t.mul(_,p);const A=t.mul(_,l),x=t.mul(t.sqr(_),d),B=t.eql(x,g);let S=t.cmov(A,_,B);return{isValid:B,value:S}}}return E}function Hn(t,e){if(Ie(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const n=$n(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,f,i,c,a,h,u;o=t.sqr(r),o=t.mul(o,e.Z),s=t.sqr(o),s=t.add(s,o),f=t.add(s,t.ONE),f=t.mul(f,e.B),i=t.cmov(e.Z,t.neg(s),!t.eql(s,t.ZERO)),i=t.mul(i,e.A),s=t.sqr(f),a=t.sqr(i),c=t.mul(a,e.A),s=t.add(s,c),s=t.mul(s,f),a=t.mul(a,i),c=t.mul(a,e.B),s=t.add(s,c),h=t.mul(o,f);const{isValid:v,value:E}=n(s,a);u=t.mul(o,r),u=t.mul(u,E),h=t.cmov(h,f,v),u=t.cmov(u,E,v);const y=t.isOdd(r)===t.isOdd(u);return u=t.cmov(t.neg(u),u,y),h=t.div(h,i),{x:h,y:u}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Rn(t){return{hash:t,hmac:(e,...n)=>ve(t,e,xe(...n)),randomBytes:Wt}}function Cn(t,e){const n=r=>Nn({...t,...Rn(r)});return Object.freeze({...n(e),create:n})}const kn=V;function it(t,e){if(t<0||t>=1<<8*e)throw new Error(`bad I2OSP call: value=${t} length=${e}`);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=t&255,t>>>=8;return new Uint8Array(n)}function Vn(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function te(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Zn(t,e,n,r){X(t),X(e),te(n),e.length>255&&(e=r(M(Nt("H2C-OVERSIZE-DST-"),e)));const{outputLen:o,blockLen:s}=r,f=Math.ceil(n/o);if(f>255)throw new Error("Invalid xmd length");const i=M(e,it(e.length,1)),c=it(0,s),a=it(n,2),h=new Array(f),u=r(M(c,t,a,it(0,1),i));h[0]=r(M(u,it(1,1),i));for(let E=1;E<=f;E++){const y=[Vn(u,h[E-1]),it(E+1,1),i];h[E]=r(M(...y))}return M(...h).slice(0,n)}function jn(t,e,n,r,o){if(X(t),X(e),te(n),e.length>255){const s=Math.ceil(2*r/8);e=o.create({dkLen:s}).update(Nt("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:n}).update(t).update(it(n,2)).update(e).update(it(e.length,1)).digest()}function de(t,e,n){Et(n,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:f,expand:i,DST:c}=n;X(t),te(e);const a=typeof c=="string"?Nt(c):c,h=r.toString(2).length,u=Math.ceil((h+o)/8),v=e*s*u;let E;if(i==="xmd")E=Zn(t,a,v,f);else if(i==="xof")E=jn(t,a,v,o,f);else if(i==="_internal_pass")E=t;else throw new Error('expand must be "xmd" or "xof"');const y=new Array(e);for(let l=0;l<e;l++){const g=new Array(s);for(let d=0;d<s;d++){const w=u*(d+l*s),p=E.subarray(w,w+u);g[d]=H(kn(p),r)}y[l]=g}return y}function Pn(t,e){const n=e.map(r=>Array.from(r).reverse());return(r,o)=>{const[s,f,i,c]=n.map(a=>a.reduce((h,u)=>t.add(t.mul(h,r),u)));return r=t.div(s,f),o=t.mul(o,t.div(i,c)),{x:r,y:o}}}function zn(t,e,n){if(typeof e!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=de(r,2,{...n,DST:n.DST,...o}),f=t.fromAffine(e(s[0])),i=t.fromAffine(e(s[1])),c=f.add(i).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){const s=de(r,1,{...n,DST:n.encodeDST,...o}),f=t.fromAffine(e(s[0])).clearCofactor();return f.assertValidity(),f},mapToCurve(r){if(!Array.isArray(r))throw new Error("mapToCurve: expected array of bigints");for(const s of r)if(typeof s!="bigint")throw new Error(`mapToCurve: expected array of bigints, got ${s} in array`);const o=t.fromAffine(e(r)).clearCofactor();return o.assertValidity(),o}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $t=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),qt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ue=BigInt(1),Tt=BigInt(2),he=(t,e)=>(t+e/Tt)/e;function Ne(t){const e=$t,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),f=BigInt(23),i=BigInt(44),c=BigInt(88),a=t*t*t%e,h=a*a*t%e,u=D(h,n,e)*h%e,v=D(u,n,e)*h%e,E=D(v,Tt,e)*a%e,y=D(E,o,e)*E%e,l=D(y,s,e)*y%e,g=D(l,i,e)*l%e,d=D(g,c,e)*g%e,w=D(d,i,e)*l%e,p=D(w,n,e)*h%e,_=D(p,f,e)*y%e,A=D(_,r,e)*a%e,x=D(A,Tt,e);if(!ft.eql(ft.sqr(x),t))throw new Error("Cannot find square root");return x}const ft=_n($t,void 0,void 0,{sqrt:Ne}),_t=Cn({a:BigInt(0),b:BigInt(7),Fp:ft,n:qt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=qt,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Ue*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,f=BigInt("0x100000000000000000000000000000000"),i=he(s*t,e),c=he(-r*t,e);let a=H(t-i*n-c*o,e),h=H(-i*r-c*s,e);const u=a>f,v=h>f;if(u&&(a=e-a),v&&(h=e-h),a>f||h>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:a,k2neg:v,k2:h}}}},It),Ht=BigInt(0),$e=t=>typeof t=="bigint"&&Ht<t&&t<$t,Mn=t=>typeof t=="bigint"&&Ht<t&&t<qt,ge={};function Lt(t,...e){let n=ge[t];if(n===void 0){const r=It(Uint8Array.from(t,o=>o.charCodeAt(0)));n=M(r,r),ge[t]=n}return It(M(n,...e))}const ee=t=>t.toRawBytes(!0).slice(1),zt=t=>ct(t,32),Zt=t=>H(t,$t),vt=t=>H(t,qt),ne=_t.ProjectivePoint,Dn=(t,e,n)=>ne.BASE.multiplyAndAddUnsafe(t,e,n);function Mt(t){let e=_t.utils.normPrivateKeyToScalar(t),n=ne.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:vt(-e),bytes:ee(n)}}function He(t){if(!$e(t))throw new Error("bad x: need 0 < x < p");const e=Zt(t*t),n=Zt(e*t+BigInt(7));let r=Ne(n);r%Tt!==Ht&&(r=Zt(-r));const o=new ne(t,r,Ue);return o.assertValidity(),o}function Re(...t){return vt(V(Lt("BIP0340/challenge",...t)))}function Kn(t){return Mt(t).bytes}function Yn(t,e,n=Wt(32)){const r=C("message",t),{bytes:o,scalar:s}=Mt(e),f=C("auxRand",n,32),i=zt(s^V(Lt("BIP0340/aux",f))),c=Lt("BIP0340/nonce",i,o,r),a=vt(V(c));if(a===Ht)throw new Error("sign failed: k is zero");const{bytes:h,scalar:u}=Mt(a),v=Re(h,o,r),E=new Uint8Array(64);if(E.set(h,0),E.set(zt(vt(u+v*s)),32),!Ce(E,r,o))throw new Error("sign: Invalid signature produced");return E}function Ce(t,e,n){const r=C("signature",t,64),o=C("message",e),s=C("publicKey",n,32);try{const f=He(V(s)),i=V(r.subarray(0,32));if(!$e(i))return!1;const c=V(r.subarray(32,64));if(!Mn(c))return!1;const a=Re(zt(i),ee(f),o),h=Dn(f,c,vt(-a));return!(!h||!h.hasEvenY()||h.toAffine().x!==i)}catch{return!1}}const Gn=(()=>({getPublicKey:Kn,sign:Yn,verify:Ce,utils:{randomPrivateKey:_t.utils.randomPrivateKey,lift_x:He,pointToBytes:ee,numberToBytesBE:ct,bytesToNumberBE:V,taggedHash:Lt,mod:H}}))(),Wn=(()=>Pn(ft,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(e=>BigInt(e)))))(),Xn=(()=>Hn(ft,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ft.create(BigInt("-11"))}))(),ke=(()=>zn(_t.ProjectivePoint,t=>{const{x:e,y:n}=Xn(ft.create(t[0]));return Wn(e,n)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ft.ORDER,m:1,k:128,expand:"xmd",hash:It}))(),Qn=(()=>ke.hashToCurve)(),Jn=(()=>ke.encodeToCurve)(),nr=Object.freeze(Object.defineProperty({__proto__:null,encodeToCurve:Jn,hashToCurve:Qn,schnorr:Gn,secp256k1:_t},Symbol.toStringTag,{value:"Module"}));export{tn as A,on as H,Fn as _,Ct as a,St as b,xe as c,Je as d,ve as e,It as f,Ke as g,Dt as h,ye as i,ze as j,Me as k,nr as l,Ze as m,At as n,We as o,Ge as p,tr as q,Wt as r,_t as s,xt as t,pe as u,Gt as v,Ee as w,yt as x,ht as y,Kt as z};
