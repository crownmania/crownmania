import{_ as r}from"./defineProperty-0f7e3690.js";import{i as u,e as E,C as v,t as A,A as e,h,W as m,l as p,F as g,f as c}from"./base.esm-47809bc2.js";import{B as C}from"./baseSolanaAdapter.esm-196858f1.js";import{a as _}from"./solanaProvider.esm-d76d1c5c.js";import"./vendor-e80652ae.js";import"./modal.esm-dc74f401.js";import"./index-67ac1df4.js";import"./firebase-b7a45c8e.js";import"./secp256k1-e5c7fdd6.js";import"./bn-7ed28666.js";import"./index-d9da954e.js";import"./_commonjs-dynamic-modules-302442b1.js";function f(o,t,i){return new Promise((n,a)=>{i>0?setTimeout(async()=>{const l=await o();l&&n(l),l||f(o,t,i-1).then(s=>(n(s),s)).catch(s=>a(s))},t):n(!1)})}const P=async function(){var o;let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{interval:1e3,count:3};return typeof window<"u"&&!!((o=window.solana)!==null&&o!==void 0&&o.isPhantom)||await f(()=>{var a;return(a=window.solana)===null||a===void 0?void 0:a.isPhantom},t.interval,t.count)?window.solana:null};class M extends C{constructor(){super(...arguments),r(this,"name",u.PHANTOM),r(this,"adapterNamespace",E.SOLANA),r(this,"currentChainNamespace",v.SOLANA),r(this,"type",A.EXTERNAL),r(this,"status",e.NOT_READY),r(this,"_wallet",null),r(this,"phantomProvider",null),r(this,"_onDisconnect",()=>{this._wallet&&(this._wallet.off("disconnect",this._onDisconnect),this.rehydrated=!1,this.status=this.status===e.CONNECTED?e.READY:e.NOT_READY,this.emit(h.DISCONNECTED))})}get isWalletConnected(){var t;return!!((t=this._wallet)!==null&&t!==void 0&&t.isConnected&&this.status===e.CONNECTED)}get provider(){return this.status!==e.NOT_READY&&this.phantomProvider?this.phantomProvider:null}set provider(t){throw new Error("Not implemented")}async init(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(await super.init(t),super.checkInitializationRequirements(),this._wallet=await P({interval:500,count:3}),!this._wallet)throw m.notInstalled();this.phantomProvider=new _({config:{chainConfig:this.chainConfig}}),this.status=e.READY,this.emit(h.READY,u.PHANTOM);try{p.debug("initializing phantom adapter"),t.autoConnect&&(this.rehydrated=!0,await this.connect())}catch(i){p.error("Failed to connect with cached phantom provider",i),this.emit("ERRORED",i)}}async connect(){var t=this;try{if(super.checkConnectionRequirements(),this.status=e.CONNECTING,this.emit(h.CONNECTING,{adapter:u.PHANTOM}),!this._wallet)throw m.notInstalled();if(this._wallet.isConnected)await this.connectWithProvider(this._wallet);else{const i=this._wallet._handleDisconnect;try{await new Promise((n,a)=>{const l=async()=>{await this.connectWithProvider(this._wallet),n(this.provider)};if(!this._wallet){a(m.notInstalled());return}this._wallet.once("connect",l),this._wallet._handleDisconnect=function(){a(m.windowClosed());for(var s=arguments.length,w=new Array(s),d=0;d<s;d++)w[d]=arguments[d];return i.apply(t._wallet,w)},this._wallet.connect().catch(s=>{a(s)})})}catch(n){throw n instanceof g?n:c.connectionError(n==null?void 0:n.message)}finally{this._wallet._handleDisconnect=i}}if(!this._wallet.publicKey)throw c.connectionError();return this._wallet.on("disconnect",this._onDisconnect),this.provider}catch(i){throw this.status=e.READY,this.rehydrated=!1,this.emit(h.ERRORED,i),i}}async disconnect(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{cleanup:!1};await super.disconnectSession();try{var i;await((i=this._wallet)===null||i===void 0?void 0:i.disconnect()),t.cleanup&&(this.status=e.NOT_READY,this.phantomProvider=null,this._wallet=null),await super.disconnect()}catch(n){this.emit(h.ERRORED,c.disconnectionError(n==null?void 0:n.message))}}async getUserInfo(){if(!this.isWalletConnected)throw c.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async addChain(t){var i;let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;super.checkAddChainRequirements(t,n),(i=this.phantomProvider)===null||i===void 0||i.addChain(t),this.addChainConfig(t)}async switchChain(t){var i;let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;super.checkSwitchChainRequirements(t,n),await((i=this.phantomProvider)===null||i===void 0?void 0:i.switchChain(t)),this.setAdapterSettings({chainConfig:this.getChainConfig(t.chainId)})}async connectWithProvider(t){if(!this.phantomProvider)throw c.connectionError("No phantom provider");return await this.phantomProvider.setupProvider(t),this.status=e.CONNECTED,this.emit(h.CONNECTED,{adapter:u.PHANTOM,reconnected:this.rehydrated}),this.provider}}export{M as PhantomAdapter};
